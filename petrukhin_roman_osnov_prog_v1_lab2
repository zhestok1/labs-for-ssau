#include <iostream>
#include <cmath>
#include <limits>    
#include <stdexcept> // Для исключений
using namespace std;

// Считаю факториальчик
unsigned long long factorial(int n) {
    if (n < 0) {
        throw invalid_argument("The factorial is not defined for negative numbers.");
    }
    unsigned long long result = 1;
    for (int i = 2; i <= n; ++i) {
        // Проверка на переполнение перед умножением
        if (result > numeric_limits<unsigned long long>::max() / i) {
            throw overflow_error("Factorial computation resulted in overflow.");
        }
        result *= i;
    }
    return result;
}

int main() {
    double x, a; // x - параметр; a - точность вычислений
    cout << "Enter the parameter x: ";

    // Получаю икс от пользователя, делаю его проверочку.
    while (true) {
        cin >> x;
        if (cin.fail() || x < 0) {
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "Invalid input. Please enter a positive number for x: ";
        }
        else {
            break;
        }
    }

    cout << "Enter the parameter a (accuracy): ";

    // Получаю точность (а), проверяю.
    while (true) {
        cin >> a;
        if (cin.fail() || a < 0) {
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << "Invalid input. Please enter a non-negative number for a: ";
        }
        else {
            break;
        }
    }

    double a_n, s_n = 0.0; // n-ый член, сумма членов ряда
    const int MAX_N = 20; // Предел для n, борюсь с бесконечностями

    for (int n = 1; n <= MAX_N; n++) {
        try {
            unsigned long long fact = factorial(2 * n + 1); // Ловим исключения

            // n-ый член и соответствующая сумма
            a_n = (pow(-1, n) * 2 * n * pow(x, 2 * n + 1)) / fact;
            s_n += a_n;

            
            cout << "Sequence member a_" << n << ": " << a_n << ", Sum: " << s_n << endl;

            // fabs - аналог модуля
            if (fabs(a_n) <= a) {
                break;
            }
        }
        catch (const overflow_error&) { 
            cout << "Factorial computation for n = " << n << " resulted in overflow: "  << endl;
            break; 
        }
    }

    cout << "Final sum of the series: " << s_n << endl;

    return 0;
}
